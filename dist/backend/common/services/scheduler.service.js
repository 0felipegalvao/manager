"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchedulerService = void 0;
const common_1 = require("@nestjs/common");
const prisma_service_1 = require("../prisma.service");
const email_service_1 = require("./email.service");
const notifications_service_1 = require("../../notifications/notifications.service");
let SchedulerService = class SchedulerService {
    constructor(prisma, emailService, notificationsService) {
        this.prisma = prisma;
        this.emailService = emailService;
        this.notificationsService = notificationsService;
    }
    // Executar todos os dias √†s 9:00 AM
    // @Cron('0 9 * * *')
    async sendDailyObligationReminders() {
        console.log('üîî Executando lembretes di√°rios de obriga√ß√µes...');
        try {
            // Buscar obriga√ß√µes que vencem nos pr√≥ximos 7 dias
            const upcomingObligations = await this.prisma.obligation.findMany({
                where: {
                    dueDate: {
                        gte: new Date(),
                        lte: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
                    },
                    status: {
                        in: ['PENDENTE', 'EM_ANDAMENTO'],
                    },
                },
                include: {
                    client: {
                        include: {
                            user: true,
                        },
                    },
                },
            });
            // Agrupar por usu√°rio
            const obligationsByUser = upcomingObligations.reduce((acc, obligation) => {
                const userId = obligation.client.userId;
                if (!acc[userId]) {
                    acc[userId] = {
                        user: obligation.client.user,
                        obligations: [],
                    };
                }
                acc[userId].obligations.push(obligation);
                return acc;
            }, {});
            // Enviar emails e criar notifica√ß√µes
            for (const [userId, data] of Object.entries(obligationsByUser)) {
                const { user, obligations } = data;
                // Criar notifica√ß√£o in-app
                for (const obligation of obligations) {
                    await this.notificationsService.createSystemNotification(user.id, 'Obriga√ß√£o Fiscal Pr√≥xima ao Vencimento', `A obriga√ß√£o "${obligation.name}" para ${obligation.client.razaoSocial} vence em ${new Date(obligation.dueDate).toLocaleDateString('pt-BR')}`, 'WARNING');
                    // Enviar email
                    await this.emailService.sendObligationReminder(user.email, user.name, obligation.name, obligation.client.razaoSocial, obligation.dueDate);
                }
            }
            console.log(`‚úÖ Enviados lembretes para ${Object.keys(obligationsByUser).length} usu√°rios`);
        }
        catch (error) {
            console.error('‚ùå Erro ao enviar lembretes di√°rios:', error);
        }
    }
    // Executar todos os dias √†s 8:00 AM para obriga√ß√µes vencidas
    // @Cron('0 8 * * *')
    async sendOverdueObligationAlerts() {
        console.log('üö® Verificando obriga√ß√µes vencidas...');
        try {
            // Buscar obriga√ß√µes vencidas
            const overdueObligations = await this.prisma.obligation.findMany({
                where: {
                    dueDate: {
                        lt: new Date(),
                    },
                    status: {
                        in: ['PENDENTE', 'EM_ANDAMENTO'],
                    },
                },
                include: {
                    client: {
                        include: {
                            user: true,
                        },
                    },
                },
            });
            // Agrupar por usu√°rio
            const obligationsByUser = overdueObligations.reduce((acc, obligation) => {
                const userId = obligation.client.userId;
                if (!acc[userId]) {
                    acc[userId] = {
                        user: obligation.client.user,
                        obligations: [],
                    };
                }
                acc[userId].obligations.push(obligation);
                return acc;
            }, {});
            // Enviar alertas
            for (const [userId, data] of Object.entries(obligationsByUser)) {
                const { user, obligations } = data;
                // Criar notifica√ß√£o in-app
                await this.notificationsService.createSystemNotification(user.id, `${obligations.length} Obriga√ß√£o(√µes) Vencida(s)`, `Voc√™ tem ${obligations.length} obriga√ß√£o(√µes) fiscal(is) vencida(s) que requerem aten√ß√£o imediata.`, 'ERROR');
            }
            console.log(`üö® Alertas enviados para ${Object.keys(obligationsByUser).length} usu√°rios sobre obriga√ß√µes vencidas`);
        }
        catch (error) {
            console.error('‚ùå Erro ao verificar obriga√ß√µes vencidas:', error);
        }
    }
    // Executar no primeiro dia de cada m√™s √†s 10:00 AM
    // @Cron('0 10 1 * *')
    async sendMonthlyReports() {
        console.log('üìä Enviando relat√≥rios mensais...');
        try {
            // Buscar todos os usu√°rios ativos
            const users = await this.prisma.user.findMany({
                where: {
                    role: {
                        in: ['ADMIN', 'CONTADOR'],
                    },
                },
            });
            const lastMonth = new Date();
            lastMonth.setMonth(lastMonth.getMonth() - 1);
            const startOfLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth(), 1);
            const endOfLastMonth = new Date(lastMonth.getFullYear(), lastMonth.getMonth() + 1, 0);
            for (const user of users) {
                const where = user.role === 'ADMIN' ? {} : { userId: user.id };
                // Calcular estat√≠sticas do m√™s passado
                const [totalClients, newClients, documentsProcessed, obligationsCompleted] = await Promise.all([
                    this.prisma.client.count({ where }),
                    this.prisma.client.count({
                        where: {
                            ...where,
                            createdAt: {
                                gte: startOfLastMonth,
                                lte: endOfLastMonth,
                            },
                        },
                    }),
                    this.prisma.document.count({
                        where: {
                            ...(user.role === 'ADMIN' ? {} : { userId: user.id }),
                            createdAt: {
                                gte: startOfLastMonth,
                                lte: endOfLastMonth,
                            },
                        },
                    }),
                    this.prisma.obligation.count({
                        where: {
                            ...(user.role === 'ADMIN' ? {} : { client: { userId: user.id } }),
                            status: 'CONCLUIDA',
                            updatedAt: {
                                gte: startOfLastMonth,
                                lte: endOfLastMonth,
                            },
                        },
                    }),
                ]);
                // Enviar relat√≥rio por email
                await this.emailService.sendMonthlyReport(user.email, user.name, {
                    totalClients,
                    newClients,
                    documentsProcessed,
                    obligationsCompleted,
                });
                // Criar notifica√ß√£o in-app
                await this.notificationsService.createSystemNotification(user.id, 'Relat√≥rio Mensal Dispon√≠vel', `Seu relat√≥rio mensal foi gerado. Confira as estat√≠sticas do m√™s passado.`, 'INFO');
            }
            console.log(`üìä Relat√≥rios mensais enviados para ${users.length} usu√°rios`);
        }
        catch (error) {
            console.error('‚ùå Erro ao enviar relat√≥rios mensais:', error);
        }
    }
    // Executar a cada 6 horas para limpeza de notifica√ß√µes antigas
    // @Cron('0 */6 * * *')
    async cleanupOldNotifications() {
        console.log('üßπ Limpando notifica√ß√µes antigas...');
        try {
            // Remover notifica√ß√µes lidas com mais de 30 dias
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const result = await this.prisma.notification.deleteMany({
                where: {
                    read: true,
                    createdAt: {
                        lt: thirtyDaysAgo,
                    },
                },
            });
            console.log(`üßπ Removidas ${result.count} notifica√ß√µes antigas`);
        }
        catch (error) {
            console.error('‚ùå Erro na limpeza de notifica√ß√µes:', error);
        }
    }
    // Executar todos os domingos √†s 18:00 para backup de logs de auditoria
    // @Cron('0 18 * * 0')
    async backupAuditLogs() {
        console.log('üíæ Fazendo backup dos logs de auditoria...');
        try {
            // Contar logs de auditoria dos √∫ltimos 7 dias
            const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            const recentLogsCount = await this.prisma.auditLog.count({
                where: {
                    createdAt: {
                        gte: sevenDaysAgo,
                    },
                },
            });
            // Criar notifica√ß√£o para administradores
            const admins = await this.prisma.user.findMany({
                where: { role: 'ADMIN' },
            });
            for (const admin of admins) {
                await this.notificationsService.createSystemNotification(admin.id, 'Backup Semanal Realizado', `Backup dos logs de auditoria conclu√≠do. ${recentLogsCount} registros dos √∫ltimos 7 dias foram processados.`, 'INFO');
            }
            console.log(`üíæ Backup conclu√≠do. ${recentLogsCount} logs processados`);
        }
        catch (error) {
            console.error('‚ùå Erro no backup de logs:', error);
        }
    }
    // M√©todo manual para testar notifica√ß√µes
    async testNotifications() {
        console.log('üß™ Testando sistema de notifica√ß√µes...');
        try {
            // Buscar um usu√°rio admin para teste
            const admin = await this.prisma.user.findFirst({
                where: { role: 'ADMIN' },
            });
            if (admin) {
                // Criar notifica√ß√£o de teste
                await this.notificationsService.createSystemNotification(admin.id, 'Teste do Sistema de Notifica√ß√µes', 'Esta √© uma notifica√ß√£o de teste para verificar se o sistema est√° funcionando corretamente.', 'INFO');
                // Enviar email de teste
                await this.emailService.sendEmail({
                    to: admin.email,
                    subject: 'Teste do Sistema de Email',
                    html: '<h1>Sistema de Email Funcionando!</h1><p>Este √© um email de teste.</p>',
                });
                console.log('üß™ Teste conclu√≠do com sucesso!');
            }
        }
        catch (error) {
            console.error('‚ùå Erro no teste de notifica√ß√µes:', error);
        }
    }
};
exports.SchedulerService = SchedulerService;
exports.SchedulerService = SchedulerService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [prisma_service_1.PrismaService,
        email_service_1.EmailService,
        notifications_service_1.NotificationsService])
], SchedulerService);
//# sourceMappingURL=scheduler.service.js.map